@namespace SpotifyAnalysis.Shared
@using MudBlazor
@using SpotifyAnalysis.Data
@using ApexCharts

@*
    Currently it is impossible to distinguish whether the clicks are coming from the legend or from the chart:
    https://github.com/apexcharts/Blazor-ApexCharts/issues/442
    https://github.com/apexcharts/Blazor-ApexCharts/issues/464
    So the solution is to toggle data series by default, but if callback is provided, we show a switch
    to call that callback instead.
*@

<MudItem lg="4" md="6">
    <MudPaper Class="pa-4">
        <ApexChart TItem="Element"
                   Title=@Title
                   Options="options"
                   OnDataPointSelection=OnDataPointSelection
                   @ref="chart">

            <ApexPointSeries TItem="Element"
                             Items="series"
                             SeriesType="SeriesType.Donut"
                             XValue="@(e => e.Label)"
                             YValue="@(e => e.Quantity)"/>
        </ApexChart>

        @if (OnClickCallback is not null) {
            <MudStack Row=true Justify="Justify.Center" AlignItems="AlignItems.Center">
                <MudInputLabel >Toggle series</MudInputLabel>
                <MudSwitch @bind-Value="@invokeCallback" Color="MudBlazor.Color.Primary" Size="MudBlazor.Size.Small" />
                <MudInputLabel>Get details</MudInputLabel>
            </MudStack>
        }
    </MudPaper>
</MudItem>

@code {
    [Parameter]
    public string Title { get; set; }
    [Parameter]
    public IEnumerable<Element> Elements { get; set; }
    private Element[] series { get; set; }
    [Parameter]
    public Action<string> OnClickCallback { get; set; }

    private ApexChart<Element> chart;
    private ApexChartOptions<Element> options { get; } = new ApexChartOptions<Element> {
        Title = new Title {
            Align = ApexCharts.Align.Center,
                Style = new TitleStyle { Color = "#fff" }
        },
        Legend = new Legend {
            Width = 200,
            OnItemClick = new LegendOnItemClick { ToggleDataSeries = true }, // doesn't do anything for pie
            Labels = new LegendLabels { Colors = ["#fff"] }
        },
        PlotOptions = new PlotOptions {
            Pie = new PlotOptionsPie {
                ExpandOnClick = false,
                Donut = new PlotOptionsDonut {
                    Labels = new DonutLabels {
                        Total = new DonutLabelTotal { FontSize = "20px", Color = "#1DB954", Formatter = @"function (w) {return w.globals.seriesTotals.reduce((a, b) => { return (a + b) }, 0)}" },
                        Value = new DonutLabelValue { Color = "#888" }
                    }
                }
            }
        }
    };

    protected override void OnInitialized() {
        Elements = Elements.OrderByDescending(e => e.Quantity);   // Descending because of how Mud displays labels. Also Change Append to Prepend

        // Any element with arbitrary low Quantity gets merged into one bit "Other"
        var allQuantitySum = Elements.Select(e => e.Quantity).Sum();
        var threshold = (int)(allQuantitySum / 220f);
        var sumQuantityBelowThreshold = Elements.Where(e => e.Quantity <= threshold).Select(e => e.Quantity).Sum();
        if (sumQuantityBelowThreshold > 0) {
            Elements = Elements.Where(e => e.Quantity > threshold);
            Elements = Elements.Append(new Element { Label = "Other", Quantity = sumQuantityBelowThreshold });
        }

        // Limit no. of legend items to 3 columns, otherwise the pie does not fit
        int leastImportantElementsCount = Math.Max(Elements.Count() - 22 * 2, 0);
        if (leastImportantElementsCount > 0) {
            var sumQuantityExceedRows = Elements.Take(leastImportantElementsCount).Select(e => e.Quantity).Sum();
            Elements = Elements.Skip(leastImportantElementsCount);
            Elements = Elements.Append(new Element { Label = "Other", Quantity = sumQuantityExceedRows });
        }

        series = Elements.ToArray();
        quantities = series.Select(e => e.Quantity).ToArray();
    }

    private int[] quantities;
    public bool invokeCallback;
    async void OnDataPointSelection(SelectedData<Element> selection) {
        if (invokeCallback)
            OnClickCallback?.Invoke(selection.DataPoint.X.ToString());
        else {
            int index = selection.DataPointIndex;
            var serie = series[index];
            if (serie.Quantity == 0)
                serie.Quantity = quantities[index];
            else
                serie.Quantity = 0;
            await chart.UpdateSeriesAsync();
        }
    }
}
