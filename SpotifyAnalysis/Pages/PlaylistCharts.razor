@page "/charts"

@using Microsoft.EntityFrameworkCore
@using SpotifyAnalysis.Data
@using SpotifyAnalysis.Data.DTO
@using SpotifyAnalysis.Data.DataAccessLayer
@using SpotifyAnalysis.Data.SpotifyAPI
@using SpotifyAPI.Web
@using System.Threading
@using MudBlazor
@using System.Collections.Concurrent

@inject SpotifyModule spotifyModule;
@inject SpotifyContext spotifyContext;
@inject IDialogService dialogService;
@inject ScopedData data;


<MudAppBar Color="Color.Surface" Fixed="false" Style="position: fixed; width: -webkit-fill-available; width: -moz-available;">
    <MudButton Variant=Variant.Outlined Class="rounded-pill" Style="width: 200px;" OnClick=TogglePlaylistTable Disabled="@(data.UserDTO is null)">@(open ? "Hide" : "Show") playlists</MudButton>
    <MudText Typo=Typo.subtitle1 Class="ml-12">@($"{playlistTable?.GetSelectedPlaylists()?.Count() ?? 0} / {data.UserDTO?.Playlists?.Count ?? 0}") playlist selected</MudText>
    <MudSpacer />
    <MudButton Variant=Variant.Outlined Class="rounded-pill" OnClick="GenerateCharts" Disabled="@(selectedCount == 0)">Generate charts</MudButton>
</MudAppBar>
<div style="height: var(--mud-appbar-height);" /> @* a cheat to offset for the AppBar's position: fixed which takes no space *@

@if (data.UserDTO is not null) {
    <MudCollapse Expanded=@open>
        <PlaylistTable @ref="playlistTable" Playlists="data.UserDTO.Playlists" SelectionChanged="UpdateGenerateButton" />
    </MudCollapse>
}

@if ((artistsSongs ?? genreSongs ?? genres) is not null) {
    <div class="pt-6 px-6">
        <MudGrid>
            @if (artistsSongs is not null) {
                <MudItemPieChart Title="Artists" Elements=artistsSongs @ref=chartRef OnClickCallback="SelectArtist" />
                <MudItemArtistPane Artist=@selectedArtist />
            }
            @if (genreSongs is not null) {
                <MudItemPieChart Title="Genres" Elements=genreSongs @ref=chartRef />
            }
            @if (genres is not null) {
                <MudItemPieChart Title="Genres general" Elements=genres @ref=chartRef />
            }
        </MudGrid>
    </div>
}

@code {
    private PlaylistTable playlistTable;

    private Elements artistsSongs;
    private Elements genreSongs;
    private Elements genres;

    List<MudItemPieChart> chartRefs = [];
    MudItemPieChart chartRef { set { chartRefs.Add(value); } }

    private bool open { get; set; }
    private void TogglePlaylistTable() => open = !open;


    IDictionary<string, ArtistDTO> allArtistsDict;
    private async Task GenerateCharts() {
        open = false;
        var selectedPlaylistsIds = playlistTable.GetSelectedPlaylists().Select(p => p.ID).ToHashSet();
        var allTracks = data.UserDTO.Playlists.Where(p => selectedPlaylistsIds.Contains(p.ID)).SelectMany(p => p.Tracks);
        allArtistsDict = new ConcurrentDictionary<string, ArtistDTO>(allTracks.SelectMany(t => t.Artists).DistinctBy(t => t.ID).ToDictionary(a => a.ID, a => a));

        var genresTask = BuildGenresGeneralAsync(allTracks, allArtistsDict);
        var genreSongsTask = BuildGenresAsync(allTracks, allArtistsDict);
        var artistsSongsTask = BuildArtistsAsync(allTracks);

        genres = await genresTask;
        genreSongs = await genreSongsTask;
        artistsSongs = await artistsSongsTask;

        await InvokeAsync(StateHasChanged);
        foreach (var chart in chartRefs)
            chart.RefreshChartAsync();
    }

    private async Task<Elements> BuildArtistsAsync(IEnumerable<TrackDTO> allTracks) {
        Elements BuildArtists() {
            var artists = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    artists.Increase(new Element { Label = artist.Name, Quantity = 1 });
            return artists;
        }

        return await Task.Run(BuildArtists);
    }

    private async Task<Elements> BuildGenresAsync(IEnumerable<TrackDTO> allTracks, IDictionary<string, ArtistDTO> allArtists) {
        Elements BuildGenres() {
            var genres = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    foreach (var genre in allArtists[artist.ID].Genres)
                        genres.Increase(new Element { Label = genre, Quantity = 1 });
            return genres;
        }

        return await Task.Run(BuildGenres);
    }

    static readonly string[] excludes = { "of", "and", "new", "music" };
    private async Task<Elements> BuildGenresGeneralAsync(IEnumerable<TrackDTO> allTracks, IDictionary<string, ArtistDTO> allArtists) {
        Elements BuildGenresGeneral() {
            var genres = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    foreach (var genre in allArtists[artist.ID].Genres)
                        foreach (string word in genre.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries))
                            genres.Increase(new Element { Label = word, Quantity = 1 });
            foreach (var exclusion in excludes)
                genres.Extract(exclusion);
            return genres;
        }

        return await Task.Run(BuildGenresGeneral);
    }

    private int selectedCount;
    internal void UpdateGenerateButton(int newSelectedCount) {
        selectedCount = newSelectedCount;
        StateHasChanged();
    }

    ArtistDTO selectedArtist;
    internal void SelectArtist(string artistName) {
        selectedArtist = allArtistsDict.FirstOrDefault(p => p.Value.Name == artistName).Value ?? selectedArtist;
        StateHasChanged();
    }
}
