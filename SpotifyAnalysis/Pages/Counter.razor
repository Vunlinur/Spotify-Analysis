@page "/counter"

@using Microsoft.EntityFrameworkCore
@using SpotifyAnalysis.Data
@using SpotifyAnalysis.Data.DTO
@using SpotifyAnalysis.Data.DataAccessLayer
@using SpotifyAnalysis.Data.SpotifyAPI
@using SpotifyAPI.Web
@using System.Threading

@inject Spotify spotify;
@inject SpotifyModule spotifyModule;
@inject SpotifyContext spotifyContext;

<p>
	<label for="userId">User ID:</label>
	<input id="userId" size="30" @bind="userID" />
	<button class="btn btn-primary" @onclick="GetPlaylists">Get playlists</button>
	<button class="btn btn-primary" disabled="@(!areAnyPlaylistsSelected)" @onclick="GenerateCharts">Generate charts</button>
</p>

@if (playlists?.Any() == true) {
	<PlaylistList @ref="playlistList" Playlists="playlists" MultiSelect="true" SelectionChanged="UpdateGenerateButton"></PlaylistList>
}
<p>
	@if (artistsSongs != null) {
		<PieChart Title="Artists" Elements="artistsSongs" OnClickCallback="SelectArtist" />
		<ArtistPane Artist="@selectedArtist"></ArtistPane>
	}
	@if (genreSongs != null) {
		<PieChart Title="Genres" Elements="genreSongs" />
	}
	@if (genres != null) {
		<PieChart Title="Genres general" Elements="genres" />
	}
</p>


@code {
	private PlaylistList playlistList;

	private string userID = "11ek5k7fhea9otrb7k2ecizzb";
	private Elements artistsSongs;
	private Elements genreSongs;
	private Elements genres;

	private FullArtist selectedArtist;
	private List<PlaylistDTO> playlists;

	public async void GetPlaylists() {
		var userData = new UserData(userID);
		var oldTask = spotify.GetUsersPublicPlaylistsAsync(userData);
		var newTask = NewGetPlaylists();
		await newTask;

		await oldTask;
		StateHasChanged();
	}

	private async Task NewGetPlaylists() {
		// TODO optimize await order
		var allUserPlaylists = await spotifyModule.GetUsersPublicPlaylistsAsync(userID);
		// Map of all playlists the user currently has in API
		var idsPlaylistsMap = allUserPlaylists.ToDictionary(p => p.ID, p => p);

		using (var db = new SpotifyContext()) {
			// Get UserDTO from DB, create new from API if not present
			UserDTO user = await db.Users
				.Include(u => u.Playlists)
				.ThenInclude(p => p.Images)
				.FirstOrDefaultAsync(u => u.ID == userID);
			if (user is null) {
				user = await spotifyModule.GetUserProfile(userID);
				await db.AddAsync(user);
			}

			// Playlists in both DB and from API
			var commonPlaylists = user.Playlists.Where(p => idsPlaylistsMap.ContainsKey(p.ID));

			// Playlists which we have in DB but have been updated
			var updatedPlaylists = commonPlaylists.Where(
				c => idsPlaylistsMap[c.ID].SnapshotID != c.SnapshotID);

			// Add new playlists
			var newPlaylists = db.Playlists.FindNewEntities(allUserPlaylists, p => p.ID);
			user.Playlists.AddRange(newPlaylists);

			// Update the existing playlists
			if (updatedPlaylists.Any()) {
				foreach (var updatedPlaylist in updatedPlaylists) {
					var correspondingUserPlaylist = idsPlaylistsMap[updatedPlaylist.ID];

					updatedPlaylist.Name = correspondingUserPlaylist.Name;
					updatedPlaylist.SnapshotID = correspondingUserPlaylist.SnapshotID;
					updatedPlaylist.Tracks = correspondingUserPlaylist.Tracks;
					updatedPlaylist.Images = correspondingUserPlaylist.Images;

					db.Entry(updatedPlaylist).State = EntityState.Modified;
				}
			}

			// TODO playlist can be referenced by other users, check if the playlist has no other users first
			// Remove the playlist we don't have anymore
			var stalePlaylists = user.Playlists.Where(p => !idsPlaylistsMap.ContainsKey(p.ID));
			if (stalePlaylists.Any())
				db.RemoveRange(stalePlaylists);

			await db.SaveChangesAsync();

			playlists = new List<PlaylistDTO>(user.Playlists);
		}
	}

	public async void GenerateCharts() {
		var n = NewGenerateCharts();
		var o = OldGenerateCharts();
		await n;
		await o;
	}

	private async Task NewGenerateCharts() {
		var selectedPlaylistsIds = playlistList.GetSelectedPlaylists().Select(p => p.ID);

		using (var db = new SpotifyContext()) {
			var user = await db.Users
				.Include(u => u.Playlists)
				.FirstOrDefaultAsync(u => u.ID == userID);
			if (user is null)
				throw new NullReferenceException($"User with ID {userID} not found");

			var playlists = await db.Playlists
				.Include(p => p.Tracks)
				.Where(p => selectedPlaylistsIds.Contains(p.ID)).ToDictionaryAsync(t => t.ID, t => t);
			var tracks = await db.Tracks.ToDictionaryAsync(t => t.ID, t => t);
			var albums = await db.Albums.ToDictionaryAsync(t => t.ID, t => t);
			var artists = await db.Artists.ToDictionaryAsync(t => t.ID, t => t);

			var playlistsAndTracks = await spotifyModule.GetMultiplePlaylistsTracksAsync(selectedPlaylistsIds);

			foreach (var data in playlistsAndTracks) {
				bool hitPlaylist = playlists.TryGetValue(data.Playlist.Id, out PlaylistDTO playlist);
				if (!hitPlaylist)
					// if not present in DB, create new
					playlist = data.Playlist.ToPlaylistDTO();
				else {
					// if present, update
					playlist.Name = data.Playlist.Name;
					playlist.SnapshotID = data.Playlist.SnapshotId;
					playlist.TracksTotal = data.Playlist.Tracks.Total;
					if (data.Playlist.Tracks.Total != data.Tracks.Count)  // TODO remove, debug safety
						throw new ApplicationException("Data mismatch between playlist.Tracks.Total and Tracks.Count");
				}
				// make sure the playlist is associated with the user
				if (!user.Playlists.Any(p => p.ID == playlist.ID))
					user.Playlists.Add(playlist);


				foreach (var fullTrack in data.Tracks) {
					foreach (var simpleArtist in fullTrack.Artists) {
						bool hitArtist = artists.TryGetValue(simpleArtist.Id, out ArtistDTO artist);
						if (!hitArtist) {
							// if not present in DB, create new
							artist = simpleArtist.ToArtistDTO();
							artists.Add(artist.ID, artist);
						}
						else {
							artist.Name = simpleArtist.Name;
						}
					}

					foreach (var simpleArtist in fullTrack.Album.Artists) {
						bool hitArtist = artists.TryGetValue(simpleArtist.Id, out ArtistDTO artist);
						if (!hitArtist) {
							// if not present in DB, create new
							artist = simpleArtist.ToArtistDTO();
							artists.Add(artist.ID, artist);
						}
						else {
							artist.Name = simpleArtist.Name;
						}
					}


					bool hitAlbum = albums.TryGetValue(fullTrack.Album.Id, out AlbumDTO album);
					if (!hitAlbum) {
						// if not present in DB, create new
						album = fullTrack.Album.ToAlbumDTO();
						var artistIds = fullTrack.Album.Artists.Select(a => a.Id);
						album.Artists = artists.Where(a => artistIds.Contains(a.Value.ID)).Select(p => p.Value).ToList();
						albums.Add(album.ID, album);
					}
					else {
						album.Name = fullTrack.Album.Name;
						album.ReleaseDate = fullTrack.Album.ReleaseDate;
						album.TotalTracks = fullTrack.Album.TotalTracks;
						// TODO update artists?
					}

					// TODO remove absent tracks from the playlist
					bool hitTrack = tracks.TryGetValue(fullTrack.Id, out TrackDTO track);
					if (!hitTrack) {
						// if not present in DB, create new
						track = fullTrack.ToTrackDTO();
						tracks.Add(track.ID, track);
						track.Album = album;
					}
					else {
						track.Name = fullTrack.Name;
						track.DurationMs = fullTrack.DurationMs;
						track.Popularity = fullTrack.Popularity;
					}
					// make sure the track is associated with the playlist
					if (!playlist.Tracks.Any(t => t.ID == track.ID))
						playlist.Tracks.Add(track);
				}
			}
			await db.SaveChangesAsync();


			/*
			return;
			var playlistsssssss = db.Playlists
				.Include(p => p.Tracks)
				.Where(p => selectedPlaylistsIds.Contains(p.ID)).ToList();

			await spotifyModule.GetMultiplePlaylistsTracksAsync(playlists);

			var tracksssss = await db.Tracks.ToDictionaryAsync(t => t.ID, t => t);
			foreach (PlaylistDTO playlist in playlists)
				for (int i = 0; i < playlist.Tracks.Count; i++)
					if (tracks.TryGetValue(playlist.Tracks[i].ID, out TrackDTO current)) {
						current.Update(playlist.Tracks[i]);
						playlist.Tracks[i] = current;
					}
					else
						tracks.Add(playlist.Tracks[i].ID, playlist.Tracks[i]);

			var artistsssss = await db.Artists.ToDictionaryAsync(t => t.ID, t => t);
			foreach (PlaylistDTO playlist in playlists) 
				foreach (TrackDTO track in playlist.Tracks) {
					for (int i = 0; i < track.Artists.Count; i++)
						if (artists.TryGetValue(track.Artists[i].ID, out ArtistDTO current)) {
							current.Update(track.Artists[i]);
							track.Artists[i] = current;
						}
						else
							artists.Add(track.Artists[i].ID, track.Artists[i]);

					for (int i = 0; i < track.Album.Artists.Count; i++)
						if (artists.TryGetValue(track.Album.Artists[i].ID, out ArtistDTO current)) {
							current.Update(track.Album.Artists[i]);
							track.Album.Artists[i] = current;
						}
						else
							artists.Add(track.Album.Artists[i].ID, track.Album.Artists[i]);
				}

			var albumsssss = await db.Albums.ToDictionaryAsync(t => t.ID, t => t);
			foreach (PlaylistDTO playlist in playlists)
				foreach (TrackDTO track in playlist.Tracks)
					if (albums.TryGetValue(track.Album.ID, out AlbumDTO current)) {
						current.Update(track.Album);
						track.Album = current;
					}
					else
						albums.Add(track.Album.ID, track.Album);

			await db.SaveChangesAsync();


			return;
			var playlistssssssssssss = db.Playlists
				.Include(p => p.Tracks).ThenInclude(t => t.Artists)
				.Include(t => t.Tracks).ThenInclude(t => t.Album).ThenInclude(a => a.Artists)
				.Where(p => selectedPlaylistsIds.Contains(p.ID)).ToList();

			await spotifyModule.GetMultiplePlaylistsTracksAsync(playlists);
			//playlists.Select(p => db.Entry(p).State = EntityState.Modified);

			playlists.RemoveDuplicateTracks(db.Tracks.ToDictionary(t => t.ID, t => t));
			var allTracks = playlists.SelectMany(p => p.Tracks).ToList();
			allTracks.RemoveDuplicateAlbums(db.Albums.ToDictionary(t => t.ID, t => t));
			var distinctArtists = db.Artists.ToDictionary(t => t.ID, t => t);
			allTracks.RemoveDuplicateArtists(distinctArtists);
			var allAlbums = allTracks.Select(t => t.Album);
			allAlbums.RemoveDuplicateArtists(distinctArtists);
			//await db.Artists.AddRangeIfNotExists(allTracks.SelectMany(t => t.Artists).DistinctBy(a => a.ID), t => t.ID); // TODO delete DistinctBy?

			await db.Tracks.AddRangeIfNotExists(allTracks, t => t.ID);
			await db.SaveChangesAsync();
			//*/
		}
	}

	private async Task OldGenerateCharts() {
		FullPlaylist PlaylistDTOToFullPlaylist(PlaylistDTO dto) {
			return new FullPlaylist() {
				Id = dto.ID,
				Name = dto.Name,
				SnapshotId = dto.SnapshotID,
				Owner = new PublicUser() {Id = dto.Owner},
				Tracks = new Paging<PlaylistTrack<IPlayableItem>>(),
				Images = []
			};
		}

		if (spotify.UserData.FullPlaylists == null)
			return;
		var getAllTracks = spotify.GetAllTracksAsync(playlistList.GetSelectedPlaylists().Select(p => PlaylistDTOToFullPlaylist(p)));
		var allTracks = await getAllTracks;
		var getAllArtists = spotify.GetAllArtistsAsync(allTracks);
		var buildArtistsSongs = BuildArtistsAsync(allTracks);
		artistsSongs = await buildArtistsSongs;
		StateHasChanged();
		var allArtists = await getAllArtists;
		var buildGenreSongs = BuildGenresAsync(allTracks, allArtists);
		var buildGenres = BuildGenresGeneralAsync(allTracks, allArtists);
		genreSongs = await buildGenreSongs;
		StateHasChanged();
		genres = await buildGenres;
		StateHasChanged();
	}

	private async Task<Elements> BuildArtistsAsync(FullTracks allTracks) {
		Elements BuildArtists() {
			artistsSongs = new Elements();
			foreach (var track in allTracks)
				foreach (var artist in track.Artists)
					artistsSongs.Increase(new Element { Label = artist.Name, Quantity = 1 });
			return artistsSongs;
		}

		return await Task<Elements>.Run(BuildArtists);
	}

	private async Task<Elements> BuildGenresAsync(FullTracks allTracks, FullArtists allArtists) {
		Elements BuildGenres() {
			genreSongs = new Elements();
			foreach (var track in allTracks)
				foreach (var artist in track.Artists)
					foreach (var genre in allArtists[artist.Id].Genres)
						genreSongs.Increase(new Element { Label = genre, Quantity = 1 });
			return genreSongs;
		}

		return await Task<Elements>.Run(BuildGenres);
	}

	private async Task<Elements> BuildGenresGeneralAsync(FullTracks allTracks, FullArtists allArtists) {
		Elements BuildGenresGeneral() {
			var genres = new Elements();
			foreach (var track in allTracks)
				foreach (var artist in track.Artists)
					foreach (var genre in allArtists[artist.Id].Genres)
						foreach (string word in genre.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries))
							genres.Increase(new Element { Label = word, Quantity = 1 });
			string[] excludes = { "of", "and", "new" };
			foreach (var exclusion in excludes)
				genres.Extract(exclusion);
			return genres;
		}

		return await Task<Elements>.Run(BuildGenresGeneral);
	}

	private bool areAnyPlaylistsSelected;
	internal void UpdateGenerateButton(bool areAnySelected) {
		if (areAnyPlaylistsSelected != areAnySelected) {
			areAnyPlaylistsSelected = areAnySelected;
			StateHasChanged();
		}
	}

	internal void SelectArtist(string artistName) {
		selectedArtist = spotify.AllArtists.First((a) => a.Name == artistName);
		StateHasChanged();
	}
}
