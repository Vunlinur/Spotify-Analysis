@page "/counter"

@using Microsoft.EntityFrameworkCore
@using SpotifyAnalysis.Data
@using SpotifyAnalysis.Data.DTO
@using SpotifyAnalysis.Data.DataAccessLayer
@using SpotifyAnalysis.Data.SpotifyAPI
@using SpotifyAPI.Web
@using System.Threading
@using MudBlazor
@using System.Collections.Concurrent

@inject SpotifyModule spotifyModule;
@inject SpotifyContext spotifyContext;
@inject IDialogService dialogService;
@inject ScopedData data;

<MudButton Variant=Variant.Outlined class="rounded-pill" OnClick="GenerateCharts" Disabled="@(!areAnyPlaylistsSelected)" >Generate charts</MudButton>


@if (data.UserDTO is not null) {
    <PlaylistList @ref="playlistList" Playlists="data.UserDTO.Playlists.ToList()" SelectionChanged="UpdateGenerateButton"></PlaylistList>
}

<MudGrid>
    @if (artistsSongs is not null) {
        <PieChartMudItem Title="Artists" Elements=artistsSongs @ref=chartRef OnClickCallback="SelectArtist" />
        <ArtistPaneMudItem Artist=@selectedArtist />
    }
    @if (genreSongs is not null) {
        <PieChartMudItem Title="Genres" Elements=genreSongs @ref=chartRef />
    }
    @if (genres is not null) {
        <PieChartMudItem Title="Genres general" Elements=genres @ref=chartRef />
    }
</MudGrid>


@code {
    private PlaylistList playlistList;

    private Elements artistsSongs;
    private Elements genreSongs;
    private Elements genres;



    List<PieChartMudItem> chartRefs = [];
    PieChartMudItem chartRef { set { chartRefs.Add(value); } }

    IDictionary<string, ArtistDTO> allArtistsDict;
    private async Task GenerateCharts() {
        var selectedPlaylistsIds = playlistList.GetSelectedPlaylists().Select(p => p.ID).ToHashSet();
        var allTracks = data.UserDTO.Playlists.Where(p => selectedPlaylistsIds.Contains(p.ID)).SelectMany(p => p.Tracks);
        allArtistsDict = new ConcurrentDictionary<string, ArtistDTO>(allTracks.SelectMany(t => t.Artists).DistinctBy(t => t.ID).ToDictionary(a => a.ID, a => a));

        var genresTask = BuildGenresGeneralAsync(allTracks, allArtistsDict);
        var genreSongsTask = BuildGenresAsync(allTracks, allArtistsDict);
        var artistsSongsTask = BuildArtistsAsync(allTracks);

        genres = genresTask;
        genreSongs = await genreSongsTask;
        artistsSongs = await artistsSongsTask;

        foreach (var chart in chartRefs)
            chart.RefreshChartAsync(); // cannot await because thread locks
    }

    private async Task<Elements> BuildArtistsAsync(IEnumerable<TrackDTO> allTracks) {
        Elements BuildArtists() {
            artistsSongs = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    artistsSongs.Increase(new Element { Label = artist.Name, Quantity = 1 });
            return artistsSongs;
        }

        return await Task<Elements>.Run(BuildArtists);
    }

    private async Task<Elements> BuildGenresAsync(IEnumerable<TrackDTO> allTracks, IDictionary<string, ArtistDTO> allArtists) {
        Elements BuildGenres() {
            genreSongs = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    foreach (var genre in allArtists[artist.ID].Genres)
                        genreSongs.Increase(new Element { Label = genre, Quantity = 1 });
            return genreSongs;
        }

        return await Task<Elements>.Run(BuildGenres);
    }

    private Elements BuildGenresGeneralAsync(IEnumerable<TrackDTO> allTracks, IDictionary<string, ArtistDTO> allArtists) {
        Elements BuildGenresGeneral() {
            var genres = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    foreach (var genre in allArtists[artist.ID].Genres)
                        foreach (string word in genre.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries))
                            genres.Increase(new Element { Label = word, Quantity = 1 });
            string[] excludes = { "of", "and", "new", "music" };
            foreach (var exclusion in excludes)
                genres.Extract(exclusion);
            return genres;
        }

        return BuildGenresGeneral();
    }

    private bool areAnyPlaylistsSelected;
    internal void UpdateGenerateButton(bool areAnySelected) {
        if (areAnyPlaylistsSelected != areAnySelected) {
            areAnyPlaylistsSelected = areAnySelected;
            StateHasChanged();
        }
    }

    ArtistDTO selectedArtist;
    internal void SelectArtist(string artistName) {
        selectedArtist = allArtistsDict.FirstOrDefault(p => p.Value.Name == artistName).Value ?? selectedArtist;
        StateHasChanged();
    }
}
