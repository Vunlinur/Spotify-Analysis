@page "/counter"

@using Microsoft.EntityFrameworkCore
@using SpotifyAnalysis.Data
@using SpotifyAnalysis.Data.DTO
@using SpotifyAnalysis.Data.DataAccessLayer
@using SpotifyAnalysis.Data.SpotifyAPI
@using SpotifyAPI.Web
@using System.Threading
@using MudBlazor

@inject Spotify spotify;
@inject SpotifyModule spotifyModule;
@inject SpotifyContext spotifyContext;

<p>
    <label for="userId">User ID:</label>
    <input id="userId" size="30" @bind="userID" />
    <button class="btn btn-primary" @onclick="GetData">Get data</button>
    <button class="btn btn-primary" @onclick="GetPlaylists">Get playlists</button>
    <button class="btn btn-primary" disabled="@(!areAnyPlaylistsSelected)" @onclick="GenerateCharts">Generate charts</button>
</p>

@if (loadValue > 0) {
    <MudProgressLinear Color="Color.Primary" Value="@loadValue" />
    <div>@loadMessage</div>
}

@if (playlists?.Any() == true) {
    <PlaylistList @ref="playlistList" Playlists="playlists" MultiSelect="true" SelectionChanged="UpdateGenerateButton"></PlaylistList>
}
<p>
    @if (artistsSongs != null) {
        <PieChart Title="Artists" Elements="artistsSongs" OnClickCallback="SelectArtist" />
        <ArtistPane Artist="@selectedArtist"></ArtistPane>
    }
    @if (genreSongs != null) {
        <PieChart Title="Genres" Elements="genreSongs" />
    }
    @if (genres != null) {
        <PieChart Title="Genres general" Elements="genres" />
    }
</p>


@code {
    private PlaylistList playlistList;

    private string userID = "11ek5k7fhea9otrb7k2ecizzb";
    private Elements artistsSongs;
    private Elements genreSongs;
    private Elements genres;

    private FullArtist selectedArtist;
    private List<PlaylistDTO> playlists;

    private int loadValue = 0;
    private string loadMessage;

    private DataFetch dataFetch;


    private void UpdateProgressBar(ushort value, string message) {
        loadValue = value;
        loadMessage = message ?? loadMessage;
        StateHasChanged();
    }

    protected override void OnInitialized() {
        base.OnInitialized();
        dataFetch = 
    }

    public async void GetPlaylists() {
        var userData = new UserData(userID);
        var oldTask = spotify.GetUsersPublicPlaylistsAsync(userData);
        var newTask = NewGetPlaylists();
        await newTask;

        await oldTask;
        StateHasChanged();
    }

    private async Task NewGetPlaylists() {
        // TODO optimize await order
        var allUserPlaylists = await spotifyModule.GetUsersPublicPlaylistsAsync(userID);
        // Map of all playlists the user currently has in API
        var idsPlaylistsMap = allUserPlaylists.ToDictionary(p => p.ID, p => p);

        using (var db = new SpotifyContext()) {
            // Get UserDTO from DB, create new from API if not present
            UserDTO user = await db.Users
                .Include(u => u.Playlists)
                .ThenInclude(p => p.Images)
                .FirstOrDefaultAsync(u => u.ID == userID);
            if (user is null) {
                user = await spotifyModule.GetUserProfile(userID);
                await db.AddAsync(user);
            }

            // Add new playlists
            var newPlaylists = db.Playlists.FindNewEntities(allUserPlaylists, p => p.ID);
            newPlaylists.Select(p => p.NeedsUpdate = true);
            user.Playlists.AddRange(newPlaylists);

            // Playlists in both DB and from API
            var commonPlaylists = user.Playlists.Where(p => idsPlaylistsMap.ContainsKey(p.ID));

            // Playlists which we have in DB but have been updated
            var updatedPlaylists = commonPlaylists.Where(
                c => idsPlaylistsMap[c.ID].SnapshotID != c.SnapshotID);
            // Update the existing playlists
            if (updatedPlaylists.Any()) {
                foreach (var updatedPlaylist in updatedPlaylists) {
                    var correspondingUserPlaylist = idsPlaylistsMap[updatedPlaylist.ID];

                    updatedPlaylist.NeedsUpdate = true;
                    updatedPlaylist.Name = correspondingUserPlaylist.Name;
                    updatedPlaylist.Tracks = correspondingUserPlaylist.Tracks;
                    updatedPlaylist.Images = correspondingUserPlaylist.Images;

                    db.Entry(updatedPlaylist).State = EntityState.Modified;
                }
            }

            // TODO playlist can be referenced by other users, check if the playlist has no other users first
            // Remove the playlist we don't have anymore
            var stalePlaylists = user.Playlists.Where(p => !idsPlaylistsMap.ContainsKey(p.ID));
            if (stalePlaylists.Any())
                db.RemoveRange(stalePlaylists);

            await db.SaveChangesAsync();

            playlists = new List<PlaylistDTO>(user.Playlists);
        }
    }

    private async Task GenerateCharts() {
        FullPlaylist PlaylistDTOToFullPlaylist(PlaylistDTO dto) {
            return new FullPlaylist() {
                    Id = dto.ID,
                    Name = dto.Name,
                    SnapshotId = dto.SnapshotID,
                    Owner = new PublicUser() { Id = dto.Owner },
                    Tracks = new Paging<PlaylistTrack<IPlayableItem>>(),
                    Images = []
                };
        }

        if (spotify.UserData.FullPlaylists == null)
            return;
        var getAllTracks = spotify.GetAllTracksAsync(playlistList.GetSelectedPlaylists().Select(p => PlaylistDTOToFullPlaylist(p)));
        var allTracks = await getAllTracks;
        var getAllArtists = spotify.GetAllArtistsAsync(allTracks);
        var buildArtistsSongs = BuildArtistsAsync(allTracks);
        artistsSongs = await buildArtistsSongs;
        StateHasChanged();
        var allArtists = await getAllArtists;
        var buildGenreSongs = BuildGenresAsync(allTracks, allArtists);
        var buildGenres = BuildGenresGeneralAsync(allTracks, allArtists);
        genreSongs = await buildGenreSongs;
        StateHasChanged();
        genres = await buildGenres;
        StateHasChanged();
    }

    private async Task<Elements> BuildArtistsAsync(FullTracks allTracks) {
        Elements BuildArtists() {
            artistsSongs = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    artistsSongs.Increase(new Element { Label = artist.Name, Quantity = 1 });
            return artistsSongs;
        }

        return await Task<Elements>.Run(BuildArtists);
    }

    private async Task<Elements> BuildGenresAsync(FullTracks allTracks, FullArtists allArtists) {
        Elements BuildGenres() {
            genreSongs = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    foreach (var genre in allArtists[artist.Id].Genres)
                        genreSongs.Increase(new Element { Label = genre, Quantity = 1 });
            return genreSongs;
        }

        return await Task<Elements>.Run(BuildGenres);
    }

    private async Task<Elements> BuildGenresGeneralAsync(FullTracks allTracks, FullArtists allArtists) {
        Elements BuildGenresGeneral() {
            var genres = new Elements();
            foreach (var track in allTracks)
                foreach (var artist in track.Artists)
                    foreach (var genre in allArtists[artist.Id].Genres)
                        foreach (string word in genre.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries))
                            genres.Increase(new Element { Label = word, Quantity = 1 });
            string[] excludes = { "of", "and", "new", "music" };
            foreach (var exclusion in excludes)
                genres.Extract(exclusion);
            return genres;
        }

        return await Task<Elements>.Run(BuildGenresGeneral);
    }

    private bool areAnyPlaylistsSelected;
    internal void UpdateGenerateButton(bool areAnySelected) {
        if (areAnyPlaylistsSelected != areAnySelected) {
            areAnyPlaylistsSelected = areAnySelected;
            StateHasChanged();
        }
    }

    internal void SelectArtist(string artistName) {
        selectedArtist = spotify.AllArtists.First((a) => a.Name == artistName);
        StateHasChanged();
    }
}
