@page "/counter"

@using Microsoft.EntityFrameworkCore
@using SpotifyAnalysis.Data
@using SpotifyAnalysis.Data.DataAccessLayer
@using SpotifyAnalysis.Data.SpotifyAPI
@using SpotifyAPI.Web
@using System.Threading

@inject Spotify spotify;
@inject SpotifyModule spotifyModule;
@inject SpotifyContext spotifyContext;

<p>
	<label for="userId">User ID:</label>
	<input id="userId" size="30" @bind="userID" />
	<button class="btn btn-primary" @onclick="GetPlaylists">Get playlists</button>
	<button class="btn btn-primary" disabled="@(!areAnyPlaylistsSelected)" @onclick="GenerateCharts">Generate charts</button>
</p>

@if (spotify.UserData?.FullPlaylists != null) {
	<PlaylistList @ref="playlistList" Playlists="spotify.UserData.FullPlaylists" MultiSelect="true" SelectionChanged="UpdateGenerateButton"></PlaylistList>
}
<p>
	@if (artistsSongs != null) {
		<PieChart Title="Artists" Elements="artistsSongs" OnClickCallback="SelectArtist" />
		<ArtistPane Artist="@selectedArtist"></ArtistPane>
	}
	@if (genreSongs != null) {
		<PieChart Title="Genres" Elements="genreSongs" />
	}
	@if (genres != null) {
		<PieChart Title="Genres general" Elements="genres" />
	}
</p>


@code {
	private PlaylistList playlistList;

	private string userID = "11ek5k7fhea9otrb7k2ecizzb";
	private Elements artistsSongs;
	private Elements genreSongs;
	private Elements genres;

	private FullArtist selectedArtist;

	public async void GetPlaylists() {
		var userData = new UserData(userID);
		var oldTask = spotify.GetUsersPublicPlaylistsAsync(userData);
		var newTask = NewGetPlaylists();
		await newTask;

		await oldTask;
		StateHasChanged();
	}

	private async Task NewGetPlaylists() {
		var userPlaylists = await spotifyModule.GetUsersPublicPlaylistsAsync(userID);
		// IDs of all playlists the user currently has
		var newIDs = userPlaylists.Select(t => t.ID).ToHashSet();

		using (var db = new SpotifyContext()) {
			// TODO setup the user!!! and take only the user's playlists

			// playlists in both DB and from API
			var commonPlaylists = await db.Playlists
				.Where(p => newIDs.Contains(p.ID))
				.ToListAsync();

			// playlists which we have in DB but have been updated
			var updatedPlaylists = commonPlaylists.Where(
				up => userPlaylists.First(p => p.ID == up.ID).SnapshotID != up.SnapshotID
			).ToList();

			// from the API playlists only take those we don't have
			var newPlaylists = userPlaylists.Where(
				up => !commonPlaylists.Any(p => p.ID == up.ID)
			).ToList();

			// add new playlists
			if (newPlaylists.Count > 0)
				await db.Playlists.AddRangeAsync(newPlaylists);

			// update existing playlists
			// TODO hash userPlaylists
			if (updatedPlaylists.Count > 0) {
				foreach (var updatedPlaylist in updatedPlaylists) {
					var correspondingUserPlaylist = userPlaylists.First(p => p.ID == updatedPlaylist.ID);

					updatedPlaylist.Name = correspondingUserPlaylist.Name;
					updatedPlaylist.SnapshotID = correspondingUserPlaylist.SnapshotID;
					updatedPlaylist.Followers = correspondingUserPlaylist.Followers;
					updatedPlaylist.Tracks = correspondingUserPlaylist.Tracks;
					updatedPlaylist.Images = correspondingUserPlaylist.Images;

					db.Entry(updatedPlaylist).State = EntityState.Modified;
				}
			}

			// TODO delete old playlists? but how, since owner != user? user needs to be in Followers?
			
			await db.SaveChangesAsync();
		}
	}

	public async void GenerateCharts() {
		var n = NewGenerateCharts();
		var o = OldGenerateCharts();
		await n;
		await o;
	}

	private async Task NewGenerateCharts() {

	}

	private async Task OldGenerateCharts() {
		if (spotify.UserData.FullPlaylists == null)
			return;
		var getAllTracks = spotify.GetAllTracksAsync(playlistList.GetSelectedPlaylists());
		var allTracks = await getAllTracks;
		var getAllArtists = spotify.GetAllArtistsAsync(allTracks);
		var buildArtistsSongs = BuildArtistsAsync(allTracks);
		artistsSongs = await buildArtistsSongs;
		StateHasChanged();
		var allArtists = await getAllArtists;
		var buildGenreSongs = BuildGenresAsync(allTracks, allArtists);
		var buildGenres = BuildGenresGeneralAsync(allTracks, allArtists);
		genreSongs = await buildGenreSongs;
		StateHasChanged();
		genres = await buildGenres;
		StateHasChanged();
	}

	private async Task<Elements> BuildArtistsAsync(FullTracks allTracks) {
		Elements BuildArtists() {
			artistsSongs = new Elements();
			foreach (var track in allTracks)
				foreach (var artist in track.Artists)
					artistsSongs.Increase(new Element { Label = artist.Name, Quantity = 1 });
			return artistsSongs;
		}

		return await Task<Elements>.Run(BuildArtists);
	}

	private async Task<Elements> BuildGenresAsync(FullTracks allTracks, FullArtists allArtists) {
		Elements BuildGenres() {
			genreSongs = new Elements();
			foreach (var track in allTracks)
				foreach (var artist in track.Artists)
					foreach (var genre in allArtists[artist.Id].Genres)
						genreSongs.Increase(new Element { Label = genre, Quantity = 1 });
			return genreSongs;
		}

		return await Task<Elements>.Run(BuildGenres);
	}

	private async Task<Elements> BuildGenresGeneralAsync(FullTracks allTracks, FullArtists allArtists) {
		Elements BuildGenresGeneral() {
			var genres = new Elements();
			foreach (var track in allTracks)
				foreach (var artist in track.Artists)
					foreach (var genre in allArtists[artist.Id].Genres)
						foreach (string word in genre.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries))
							genres.Increase(new Element { Label = word, Quantity = 1 });
			string[] excludes = { "of", "and", "new" };
			foreach (var exclusion in excludes)
				genres.Extract(exclusion);
			return genres;
		}

		return await Task<Elements>.Run(BuildGenresGeneral);
	}

	private bool areAnyPlaylistsSelected;
	internal void UpdateGenerateButton(bool areAnySelected) {
		if (areAnyPlaylistsSelected != areAnySelected) {
			areAnyPlaylistsSelected = areAnySelected;
			StateHasChanged();
		}
	}

	internal void SelectArtist(string artistName) {
		selectedArtist = spotify.AllArtists.First((a) => a.Name == artistName);
		StateHasChanged();
	}
}
